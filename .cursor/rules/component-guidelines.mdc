# Vue Component Guidelines

## Core Principles

1. **Component Architecture**
   - Use Vue 3 Composition API
   - Follow TypeScript best practices
   - Maintain single responsibility principle
   - Keep components focused and modular

2. **File Structure**
   ```
   component/
   ├── Component.tsx         # Main component (minimal setup)
   ├── RenderComponent.tsx   # Render logic
   ├── type.ts              # Types and props definitions
   ├── utils.ts             # Component-specific utilities
   ├── components/          # Subcomponents
   │   └── ...
   ├── hooks/              # Custom hooks
   │   └── ...
   └── __tests__/         # Tests
       └── Component.spec.ts
   ```

3. **Component Definition**
   ```typescript
   // Component.tsx
   import type { SVGAttributes, SlotsType } from 'vue'
   import { defineComponent } from 'vue'
   import type { ComponentProps, ComponentPropsWithSVG } from './type'
   import { ComponentVueProps } from './type'
   import { RenderComponent } from './RenderComponent'
   import { useComponentProps } from './hooks/useComponentProps'

   export const Component = defineComponent<ComponentPropsWithSVG>({
     name: 'Component',
     props: ComponentVueProps,
     inheritAttrs: false,
     setup(props: ComponentProps, { attrs, slots }) {
       const componentProps = useComponentProps(props)
       return () => (
         <RenderComponent {...componentProps.value}>
           {slots.default?.()}
         </RenderComponent>
       )
     }
   })
   ```

4. **Props Definition**
   ```typescript
   // type.ts
   import type { PropType } from 'vue'
   import type { DataKey } from '../../types/common'

   // Base props interface
   export interface ComponentProps {
     required: number
     optional?: string
     complex?: ComplexType
   }

   // Vue props definition with validation
   export const ComponentVueProps = {
     // Required props
     required: {
       type: Number,
       required: true
     },
     // Optional with default
     optional: {
       type: String,
       default: 'default'
     },
     // Complex types
     complex: {
       type: Object as PropType<ComplexType>,
       default: () => ({})
     },
     // Function props
     handler: Function as PropType<(data: any) => void>,
     // Union types
     dataKey: [String, Function] as PropType<DataKey<any>>
   }

   // Combined type for SVG elements
   export type ComponentPropsWithSVG = ComponentProps & SVGAttributes
   ```

5. **Render Component**
   ```typescript
   // RenderComponent.tsx
   import { defineComponent, computed } from 'vue'
   import { useComponentState } from './hooks/useComponentState'
   import { useComponentHandlers } from './hooks/useComponentHandlers'

   export const RenderComponent = defineComponent({
     name: 'RenderComponent',
     props: ComponentVueProps,
     setup(props, { slots }) {
       const { state } = useComponentState(props)
       const { handlers } = useComponentHandlers(props)

       // Computed properties
       const computedValue = computed(() => {
         // Derived values
       })

       return () => (
         // Render logic
       )
     }
   })
   ```

## Best Practices

1. **Props Management**
   - Define clear prop interfaces
   - Use PropType for complex types
   - Provide sensible defaults
   - Validate required props
   - Document prop types and purpose

2. **Component Organization**
   - Main component should be minimal
   - Move render logic to RenderComponent
   - Extract complex logic to hooks
   - Keep components focused and single-purpose

3. **State Management**
   - Use composables for state logic
   - Prefer refs for reactive data
   - Use computed for derived values
   - Handle side effects in hooks

4. **Event Handling**
   - Type event handlers properly
   - Use emits declaration
   - Follow Vue event naming conventions
   - Handle cleanup in onUnmounted

5. **Performance**
   - Use computed properties
   - Implement proper memoization
   - Avoid unnecessary watchers
   - Consider lazy loading

## Example Implementation

```typescript
// hooks/useComponentProps.ts
export function useComponentProps(props: ComponentProps) {
  return computed(() => ({
    ...props,
    // Derived or transformed props
  }))
}

// hooks/useComponentState.ts
export function useComponentState(props: ComponentProps) {
  const state = ref({
    // Component state
  })

  onMounted(() => {
    // Setup
  })

  onUnmounted(() => {
    // Cleanup
  })

  return { state }
}

// hooks/useComponentHandlers.ts
export function useComponentHandlers(props: ComponentProps) {
  const handlers = {
    handleEvent: (e: Event) => {
      // Event handling
    }
  }

  return { handlers }
}
```

## Testing Guidelines

1. **Unit Tests**
   ```typescript
   describe('Component', () => {
     it('renders correctly', () => {
       const wrapper = mount(Component, {
         props: {
           required: 1
         }
       })
       expect(wrapper.html()).toMatchSnapshot()
     })

     it('validates props', () => {
       const warn = vi.spyOn(console, 'warn')
       mount(Component, {
         props: {
           required: 'invalid'
         }
       })
       expect(warn).toHaveBeenCalled()
     })
   })
   ```

2. **Integration Tests**
   - Test component interactions
   - Test with parent components
   - Test store integration
   - Test event handling

## Documentation

1. **Component Documentation**
   ```typescript
   /**
    * Component description
    * @component
    *
    * @example
    * <Component
    *   required={1}
    *   optional="value"
    * />
    */
   ```

2. **Props Documentation**
   ```typescript
   export interface ComponentProps {
     /** Description of required prop */
     required: number
     /** Description of optional prop */
     optional?: string
   }
   ```

